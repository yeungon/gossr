### GOSSR - A Golang Template Applying Clean Architecture with DDD and Server-Side Rendering

ALERT: WIP

I wanted to create a ready-to-use and scalable Golang template for building web applications with HTMX and server-side rendering (SSR). This template, GoSSR, is based on my personal experiences from building several Golang projects. GoSSR implements Clean Architecture (modular approach) and Domain-Driven Design (DDD) Lite principles, with full support for server-side rendering. 

Please take a look at the references and my notes on discussions and lessons learned while creating the GoSSR template.

### Project Structure

### Features
- Clean Architecture with Domain-Driven Design  
- Server-side rendering  
- PostgreSQL with **SQLC** for type-safe queries  
- Modular design with independent business domains  
- **Chi** router for HTTP routing  
- Database migrations support  

### Prerequisites
- Go **1.24+**  
- PostgreSQL  
- `golang-migrate`  
- `sqlc`  
- `go-chi`

### Configuration
Configuration is managed through `config.go` with environment variables. Please see .env_example for more details:

- `HTTP_ADDR`: Server address (default: `:8080`)  
- `DB_URL`: PostgreSQL connection string  

### Getting Started

1. Clone the repository  
2. Copy `.env_example` → `.env` and configure  
3. Initialize the database:  
   ```bash
   make up
   ```
4. Start the development server:  
   ```bash
   make dev
   ```
### Database Migrations
Manage your database using the commands in the `Makefile`:

```bash
make up     # Apply migrations
make down   # Rollback migrations
```

### Domain Modules

### Article Module
- Located at `internal/module/articles`
- `domain/article.go`: articles domain model  
- `business/service.go`: Business logic  
- `storage/postgres.go`: Data persistence  

### Category Module
- Located at `internal/module/categories`
- `domain/category.go`: category domain model  
- `business/service.go`: Business processing  
- `storage/postgres.go`: Data persistence  


### HTTP Endpoints

### Articles
- `GET /article/{id}` → Get article by ID  

### Category
- `GET /category/{id}` → Get category by ID  

### Development
The application uses:
- `app.NewServer` → HTTP server setup  
- `app.NewRouter` → Routing configuration  
- **Chi middleware** for logging and recovery  

### Directory Structure

- `cmd` → Application entrypoints  
- `internal` → Private application code  
- `config` → Configuration management  
- `pkg` → Shared utilities  
- `html` → Template files for server-side rendering  


### Project Layout
The project follows **Clean Architecture** principles with clear separation of layers:

- **Domain Layer** → Domain models and interfaces  
- **Business Layer** → Use cases and business rules  
- **Infrastructure Layer** → External interfaces  
- **Transport Layer** → HTTP handlers  

Each module is **self-contained** with its own layers following **DDD principles**.

```module/
 ├── business/    (Service and Repository)
 ├── transport/   (Controller)
 ├── domain/      (entity and validation)
 ├── mapper/      (Mapping between model sqlc <-> domain)
 ├── queries/     (We write raw queries here which will be then used by sqlc to generate type safe code which is then put in /sqlc folder.)
 ├── storage/
 └── sqlc/        (Generated by sqlc)
infras/           (shared infrastructure)
```

### Alternative name

- domain -> entity (quite common option)
- transport -> controllers (simplier)
- business --> service (in which repository is simply a file given its succint content - mainly interface)

### References
- https://github.com/golang-standards/project-layout
- https://evrone.com/blog/go-clean-template
- https://github.com/bernardinorafael/go-boilerplate
- https://github.com/bxcodec/go-clean-arch
- https://philipptanlak.com/web-frontends-in-go/ or https://archive.is/ZiPT6 (I adopt a strategy to structe template layout in Laravel way from this blog. Kudo Philipp.)
- https://www.damianopetrungaro.com/posts/ddd-using-golang-tactical-design/ or https://archive.is/1xKhb (the snapshot created by myself) (I learn about domain and validation of the entity, how to initialize a new struct (domain/entity) via New pattern to trigger internal/"build-in" validation)

### License
This project is licensed under the **MIT License**.


